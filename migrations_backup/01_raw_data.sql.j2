CREATE EXTENSION IF NOT EXISTS timescaledb;
CREATE TABLE "user" (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), name TEXT NOT NULL UNIQUE);
CREATE TABLE product (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), name TEXT NOT NULL UNIQUE);

CREATE TABLE price_update (
    product_id UUID NOT NULL REFERENCES product(id) ON DELETE CASCADE,
    "timestamp" TIMESTAMPTZ NOT NULL,
    price NUMERIC(20, 6) NOT NULL,
    PRIMARY KEY (product_id, "timestamp")
);

CREATE TABLE cashflow (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Identity
    user_id UUID NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES product(id) ON DELETE CASCADE,
    "timestamp" TIMESTAMPTZ NOT NULL,

    -- The 5 interdependent transaction fields
    -- At least 3 must be provided; trigger will derive the other 2
    units_delta NUMERIC(20, 6),           -- positive for buys, negative for sells
    execution_price NUMERIC(20, 6),       -- price per unit
    execution_money NUMERIC(20, 6),       -- units_delta × execution_price
    user_money NUMERIC(20, 6),            -- execution_money + fees (what left/entered bank)
    fees NUMERIC(20, 6),                  -- always >= 0 (cost to user)

    -- Deduplication: only one transaction per user/product/timestamp
    CONSTRAINT unique_cashflow UNIQUE (user_id, product_id, "timestamp")
);

CREATE INDEX idx_cashflow_user_product_time ON cashflow(user_id, product_id, "timestamp" DESC);
CREATE INDEX idx_cashflow_timestamp ON cashflow("timestamp" DESC);
CREATE INDEX idx_price_update_time ON price_update(product_id, "timestamp" DESC);

SELECT create_hypertable('price_update', 'timestamp', chunk_time_interval => INTERVAL '1 month');
ALTER TABLE price_update SET (timescaledb.compress,
                               timescaledb.compress_segmentby = 'product_id',
                               timescaledb.compress_orderby = 'timestamp DESC');
SELECT add_compression_policy('price_update', INTERVAL '7 days');

{% for g in GRANULARITIES %}

    CREATE MATERIALIZED VIEW price_update_{{ g.suffix }}
    WITH (timescaledb.continuous) AS
    SELECT product_id,
           time_bucket('{{ g.interval }}', "timestamp") AS bucket,
           last(price, "timestamp") AS price  -- Closing price for the bucket
    FROM price_update
    GROUP BY product_id, time_bucket('{{ g.interval }}', "timestamp")
    WITH NO DATA;

    SELECT add_continuous_aggregate_policy('price_update_{{ g.suffix }}',
                                           start_offset => INTERVAL '1 month',
                                           end_offset => INTERVAL '1 minute',
                                           schedule_interval => INTERVAL '{{ g.interval }}');

    CREATE INDEX idx_price_update_{{ g.suffix }}_product_bucket
        ON price_update_{{ g.suffix }} (product_id, bucket DESC) INCLUDE (price);

{% endfor %}


-- This trigger ensures data integrity for the 5 interdependent cashflow fields:
--   units_delta, execution_price, execution_money, user_money, fees
CREATE OR REPLACE FUNCTION validate_and_fill_cashflow()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.units_delta IS NULL THEN
        -- We can derive units from execution money and price
        IF NEW.execution_money IS NOT NULL AND NEW.execution_price IS NOT NULL THEN
            NEW.units_delta := NEW.execution_money / NEW.execution_price;
        ELSE
            RAISE EXCEPTION 'units_delta is NULL and cannot be derived';
        END IF;
    END IF;

    IF NEW.execution_price IS NULL THEN
        -- We can derive execution price from money and units
        IF NEW.execution_money IS NOT NULL AND NEW.units_delta IS NOT NULL THEN
            NEW.execution_price := NEW.execution_money / NEW.units_delta;
        ELSE
            RAISE EXCEPTION 'execution_price is NULL and cannot be derived';
        END IF;
    END IF;

    IF NEW.execution_money IS NULL THEN
        -- We can derive execution money from units and price
        IF NEW.units_delta IS NOT NULL AND NEW.execution_price IS NOT NULL THEN
            NEW.execution_money := NEW.units_delta * NEW.execution_price;
        -- or from user money and fees
        ELSIF NEW.user_money IS NOT NULL AND NEW.fees IS NOT NULL THEN
            NEW.execution_money := NEW.user_money - NEW.fees;
        ELSE
            RAISE EXCEPTION 'execution_money is NULL and cannot be derived';
        END IF;
    END IF;

    IF NEW.user_money IS NULL THEN
        -- We can derive user money from execution money and fees
        IF NEW.execution_money IS NOT NULL AND NEW.fees IS NOT NULL THEN
            NEW.user_money := NEW.execution_money + NEW.fees;
        ELSE
            RAISE EXCEPTION 'user_money is NULL and cannot be derived';
        END IF;
    END IF;

    IF NEW.fees IS NULL THEN
        -- We can derive fees from user money and execution money
        IF NEW.user_money IS NOT NULL AND NEW.execution_money IS NOT NULL THEN
            NEW.fees := NEW.user_money - NEW.execution_money;
        ELSE
            RAISE EXCEPTION 'fees is NULL and cannot be derived';
        END IF;
    END IF;

    -- Validate execution price = money / units
    IF abs((NEW.units_delta * NEW.execution_price) - NEW.execution_money) > 0.01 THEN
        RAISE EXCEPTION
            'Inconsistent data: execution_money (%) != units_delta (%) × execution_price (%). Difference: %',
            NEW.execution_money, NEW.units_delta, NEW.execution_price,
            abs((NEW.units_delta * NEW.execution_price) - NEW.execution_money);
    END IF;

    -- Validate user money = execution money + fees
    IF abs((NEW.execution_money + NEW.fees) - NEW.user_money) > 0.01 THEN
        RAISE EXCEPTION 'Inconsistent data: user_money (%) != execution_money (%) + fees (%). Difference: %',
            NEW.user_money, NEW.execution_money, NEW.fees,
            abs((NEW.execution_money + NEW.fees) - NEW.user_money);
    END IF;

    -- Validate: fees must be non-negative
    IF NEW.fees < 0 THEN
        RAISE EXCEPTION 'Fees must be non-negative (>= 0), got %', NEW.fees;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach trigger to cashflow table
CREATE TRIGGER cashflow_fill_and_validate
    BEFORE INSERT OR UPDATE ON cashflow
    FOR EACH ROW
    EXECUTE FUNCTION validate_and_fill_cashflow();

CREATE OR REPLACE FUNCTION invalidate_and_repair_all()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM invalidate_cumulative_cashflow_cache(NEW.user_id, NEW.product_id, NEW."timestamp");
    PERFORM repair_cumulative_cashflow(NEW.user_id, NEW.product_id);

    PERFORM invalidate_user_product_timeline_cache(NEW.user_id, NEW.product_id, NEW."timestamp");
    PERFORM repair_user_product_timeline(NEW.user_id, NEW.product_id);

    PERFORM invalidate_user_timeline_cache(NEW.user_id, NEW."timestamp");
    PERFORM repair_user_timeline(NEW.user_id);

    RETURN NEW;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER cashflow_auto_repair_caches
    AFTER INSERT ON cashflow
    FOR EACH ROW
    EXECUTE FUNCTION invalidate_and_repair_all();
