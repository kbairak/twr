-- =============================================================================
-- BASE VIEWS: Query Infrastructure (Jinja2 Template)
-- =============================================================================
-- This migration creates the base view system for multiple granularities.
-- For each granularity defined in granularities.py:
-- - TimescaleDB continuous aggregate (bucketed price data)
-- - Base computation view (compute timeline from raw data + buckets)
-- Note: Combined views are created in a later migration after cache tables exist
-- =============================================================================

{% for g in GRANULARITIES %}
-- =============================================================================
-- {{ g.suffix }} GRANULARITY: {{ g.description }}
-- Use case: {{ g.use_case }}
-- Cache retention: {{ g.cache_retention or 'indefinite' }}
-- Real-time tier: {{ 'enabled' if g.include_realtime else 'disabled' }}
-- =============================================================================

-- -----------------------------------------------------------------------------
-- TimescaleDB Continuous Aggregate ({{ g.suffix }})
-- -----------------------------------------------------------------------------
-- Create continuous aggregate for {{ g.interval }} price buckets
-- This dramatically reduces timeline row count

CREATE MATERIALIZED VIEW product_price_{{ g.suffix }}
WITH (timescaledb.continuous) AS
SELECT product_id,
       time_bucket('{{ g.interval }}', timestamp) AS bucket,
       last(price, timestamp) AS price
FROM product_price
GROUP BY product_id, time_bucket('{{ g.interval }}', timestamp)
WITH NO DATA;

-- Auto-refresh policy: refresh every {{ g.interval }}, keeping data up to 1 minute ago fresh
SELECT add_continuous_aggregate_policy('product_price_{{ g.suffix }}',
    start_offset => INTERVAL '1 month',
    end_offset => INTERVAL '1 minute',
    schedule_interval => INTERVAL '{{ g.interval }}'
);

-- Index for fast lookups by product and time range
CREATE INDEX ON product_price_{{ g.suffix }} (product_id, bucket DESC);

-- -----------------------------------------------------------------------------
-- Base Computation View ({{ g.suffix }})
-- -----------------------------------------------------------------------------
-- Base timeline view ({{ g.suffix }} granularity): Portfolio state at each point in time when something changed
-- For each user-product pair, only includes relevant events:
-- - Cash flows for that specific user-product (exact timestamps)
-- - Price changes for that product using {% if g.include_realtime %}THREE-TIER{% else %}TWO-TIER{% endif %} approach:
--   Tier 1: Cash flows (exact timestamps)
--   Tier 2: Bucketed data from continuous aggregate ({{ g.interval }} buckets)
{% if g.include_realtime %}--   Tier 3: Recent raw data with exact timestamps (after last materialized bucket)
{% endif %}-- This avoids creating redundant rows for products a user doesn't hold
-- This is the "base" view that computes everything - used by the cache system
CREATE VIEW user_product_timeline_base_{{ g.suffix }} AS
WITH
  -- Get user-product pairs with their first cash flow timestamp
  -- MATERIALIZED to avoid duplicate sequential scans on user_cash_flow
  user_product_first_flow AS MATERIALIZED (
      SELECT user_id, product_id, MIN(timestamp) AS first_ts
      FROM user_cash_flow
      GROUP BY user_id, product_id
  ),
{% if g.include_realtime %}
  -- Find the last materialized bucket per product in the continuous aggregate
  -- This is the boundary between bucketed historical data and raw recent data
  last_materialized_bucket AS (
      SELECT product_id, MAX(bucket) AS last_bucket
      FROM product_price_{{ g.suffix }}
      GROUP BY product_id
  ),
{% endif %}
  -- Combine cash flows and relevant price changes into events
  -- Use UNION ALL since we know there are no duplicates (cash flows and prices have different sources)
  user_product_events AS (
      -- TIER 1: Cash flow events with all their data
      SELECT
          user_id,
          product_id,
          timestamp,
          cumulative_units AS holdings,
          cumulative_money AS net_deposits,
          cumulative_twr_factor AS twr_factor_at_last_flow,
          market_price AS price,  -- Market price at this cash flow
          TRUE AS is_cash_flow
      FROM user_cash_flow

      UNION ALL

      -- TIER 2: Price change events from continuous aggregate (bucketed timestamps)
      -- Uses {{ g.interval }} bucketed prices for data reduction
      SELECT
          uff.user_id,
          uff.product_id,
          pp.bucket AS timestamp,  -- Use bucketed timestamp
          NULL::NUMERIC AS holdings,
          NULL::NUMERIC AS net_deposits,
          NULL::NUMERIC AS twr_factor_at_last_flow,
          pp.price,  -- Price at this price change event (last price in {{ g.interval }} bucket)
          FALSE AS is_cash_flow
      FROM user_product_first_flow uff
      JOIN product_price_{{ g.suffix }} pp ON pp.product_id = uff.product_id
      WHERE pp.bucket > uff.first_ts  -- Only prices AFTER first flow
{% if g.include_realtime %}

      UNION ALL

      -- TIER 3: Price change events from raw data (exact timestamps, recent)
      -- Captures real-time price updates that haven't been materialized yet
      SELECT
          uff.user_id,
          uff.product_id,
          pp.timestamp,  -- Use exact timestamp for real-time data
          NULL::NUMERIC AS holdings,
          NULL::NUMERIC AS net_deposits,
          NULL::NUMERIC AS twr_factor_at_last_flow,
          pp.price,
          FALSE AS is_cash_flow
      FROM user_product_first_flow uff
      JOIN product_price pp ON pp.product_id = uff.product_id
      LEFT JOIN last_materialized_bucket lmb ON lmb.product_id = pp.product_id
      WHERE pp.timestamp > uff.first_ts  -- Only prices AFTER first flow
        AND (
            -- Include if no materialized buckets exist yet (new product)
            lmb.last_bucket IS NULL
            -- Or if timestamp is after the last materialized bucket's interval
            -- Buckets are [bucket, bucket+interval), so raw data starts at bucket+interval
            OR pp.timestamp >= lmb.last_bucket + INTERVAL '{{ g.interval }}'
        )
{% endif %}
  ),

  -- For each event, get the latest cash flow data using LATERAL join
  events_with_state AS (
      SELECT
          upe.user_id,
          upe.product_id,
          upe.timestamp,
          upe.is_cash_flow,
          upe.price AS current_price,  -- Price at this event (already known)
          -- For cash flow events, use their own data; for price events, get latest cash flow
          COALESCE(upe.holdings, cf_latest.cumulative_units) AS holdings,
          COALESCE(upe.net_deposits, cf_latest.cumulative_money) AS net_deposits,
          COALESCE(upe.twr_factor_at_last_flow, cf_latest.cumulative_twr_factor) AS twr_factor_at_last_flow,
          -- Price at the last cash flow (for TWR calculation)
          -- For both event types, we need the price from the PREVIOUS cash flow
          cf_latest.market_price AS price_at_last_flow
      FROM user_product_events upe
      LEFT JOIN LATERAL (
          SELECT cumulative_units, cumulative_money, cumulative_twr_factor, market_price
          FROM user_cash_flow cf
          WHERE cf.user_id = upe.user_id
            AND cf.product_id = upe.product_id
            AND cf.timestamp < upe.timestamp  -- Strictly before (not <=)
          ORDER BY cf.timestamp DESC
          LIMIT 1
      ) cf_latest ON TRUE  -- Always join, not just for price events
  )

-- Final select: calculate current value and TWR from the state we've gathered
-- No need for additional price lookups - we have everything we need!
SELECT
    user_id,
    product_id,
    timestamp,
    holdings,
    net_deposits,
    current_price,
    holdings * current_price AS current_value,
    -- Real-time TWR calculation depends on event type:
    -- - For cashflow events: use cumulative_twr_factor directly (already correct)
    -- - For price events: compound TWR at last flow with price change since then
    CASE
        WHEN is_cash_flow THEN
            -- Cashflow event: twr_factor_at_last_flow is actually the cumulative TWR factor
            -- as of this cashflow (stored in user_cash_flow.cumulative_twr_factor)
            COALESCE(twr_factor_at_last_flow - 1, 0)
        WHEN
            price_at_last_flow > 0
            AND current_price IS NOT NULL
            AND twr_factor_at_last_flow IS NOT NULL
            THEN
                -- Price event: compound TWR from last cashflow with price change
                twr_factor_at_last_flow
                * (current_price / price_at_last_flow)
                - 1
        ELSE
            0
    END AS current_twr
FROM events_with_state
WHERE
    holdings IS NOT NULL
    AND holdings != 0  -- Exclude times when user has no holdings
ORDER BY user_id, product_id, timestamp;

-- Base user-level timeline ({{ g.suffix }} granularity): Aggregated portfolio value over time
-- Computes aggregations from user_product_timeline_base_{{ g.suffix }} (not the combined view)
CREATE VIEW user_timeline_base_{{ g.suffix }} AS
SELECT
    user_id,
    timestamp,
    SUM(net_deposits) AS total_net_deposits,
    SUM(current_value) AS total_value,
    -- Value-weighted TWR across all products
    CASE
        WHEN SUM(current_value) > 0
            THEN
                SUM(current_twr * current_value) / SUM(current_value)
        ELSE
            0
    END AS value_weighted_twr
FROM user_product_timeline_base_{{ g.suffix }}
GROUP BY user_id, timestamp
ORDER BY user_id, timestamp;

{% endfor %}
