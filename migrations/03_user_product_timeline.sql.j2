{% for g in GRANULARITIES %}

    CREATE TABLE user_product_timeline_cache_{{ g.suffix }} (
        -- Denormalized fields for efficient querying
        user_id UUID NOT NULL,
        product_id UUID NOT NULL,
        "timestamp" TIMESTAMPTZ NOT NULL,

        -- Portfolio state (all cumulative fields from cumulative_cashflow)
        units_held NUMERIC(20, 6),
        net_investment NUMERIC(20, 6),
        deposits NUMERIC(20, 6),
        withdrawals NUMERIC(20, 6),
        fees NUMERIC(20, 6),
        buy_units NUMERIC(20, 6),
        sell_units NUMERIC(20, 6),
        buy_cost NUMERIC(20, 6),
        sell_proceeds NUMERIC(20, 6),

        -- Market data
        market_value NUMERIC(20, 6),  -- units_held Ã— market_price

        PRIMARY KEY (user_id, product_id, "timestamp")
    );

    CREATE INDEX idx_user_product_timeline_cache_{{ g.suffix }}_user_product
        ON user_product_timeline_cache_{{ g.suffix }}(user_id, product_id, "timestamp" DESC);
    CREATE INDEX idx_user_product_timeline_cache_{{ g.suffix }}_timestamp
        ON user_product_timeline_cache_{{ g.suffix }}("timestamp" DESC);

    -- COMBINED VIEW: Cache + Delta Pattern
    --   1. Pre-computed cached rows (fast)
    --   2. Fresh cashflow events after watermark
    --   3. Fresh price bucket events after watermark
    --
    -- Events included:
    --   - All cashflow events (from cumulative_cashflow)
    --   - Price bucket events for user-products with any cashflow history (even if units_held = 0)

    CREATE VIEW user_product_timeline_{{ g.suffix }} AS
        WITH
            watermark AS (
                SELECT COALESCE(MAX("timestamp"), '-infinity'::timestamptz) AS watermark
                FROM user_product_timeline_cache_{{ g.suffix }}
            )
            {% if g.include_realtime %},
                view_watermark AS (
                    SELECT COALESCE(MAX(bucket), '-infinity'::timestamptz) AS last_bucketed_timestamp
                    FROM price_update_{{ g.suffix }}
                )
            {% endif %}

        -- Query 1: Get the whole cache
        SELECT user_id, product_id, "timestamp", units_held, net_investment, deposits, withdrawals,
            fees, buy_units, sell_units, buy_cost, sell_proceeds, market_value
        FROM user_product_timeline_cache_{{ g.suffix }}
        {% if g.cache_retention %}
            WHERE "timestamp" > NOW() - INTERVAL '{{ g.cache_retention }}'
        {% endif %}

        UNION ALL

        -- Query 2: Get all cashflows, include latest market price for each
        SELECT cc.user_id, cc.product_id, cc."timestamp", cc.units_held, cc.net_investment,
            cc.deposits, cc.withdrawals, cc.fees, cc.buy_units, cc.sell_units, cc.buy_cost,
            cc.sell_proceeds, p.market_price * cc.units_held AS market_value
        FROM watermark
            INNER JOIN cumulative_cashflow cc
                {% if g.cache_retention %}
                    ON cc."timestamp" > NOW() - INTERVAL '{{ g.cache_retention }}'
                {% else %}
                    ON cc."timestamp" > watermark.watermark
                {% endif %}
            LEFT JOIN LATERAL (
                SELECT price AS market_price
                FROM price_update_{{ g.suffix }}
                WHERE price_update_{{ g.suffix }}.product_id = cc.product_id AND
                    price_update_{{ g.suffix }}.bucket <= cc."timestamp"
                ORDER BY price_update_{{ g.suffix }}.bucket DESC
                LIMIT 1
            ) p ON true

        UNION ALL

        -- Query 3: Get all price updates (bucketed), consult with most recent cashflow for each user-product
        SELECT user_id, product_id, "timestamp", units_held, net_investment, deposits, withdrawals,
            fees, buy_units, sell_units, buy_cost, sell_proceeds,
            market_price * units_held AS market_value
        FROM (
            SELECT cc.user_id, cc.product_id, pp.bucket AS "timestamp",
                cc.units_held, cc.net_investment, cc.deposits, cc.withdrawals, cc.fees,
                cc.buy_units, cc.sell_units, cc.buy_cost, cc.sell_proceeds,
                pp.price AS market_price,
                ROW_NUMBER() OVER (PARTITION BY pp.product_id, pp.bucket, cc.user_id
                                    ORDER BY cc."timestamp" DESC) AS row_number
            FROM watermark
                INNER JOIN price_update_{{ g.suffix }} pp
                    {% if g.cache_retention %}
                        ON pp.bucket > NOW() - INTERVAL '{{ g.cache_retention }}'
                    {% else %}
                        ON pp.bucket > watermark.watermark
                    {% endif %}
                LEFT OUTER JOIN cumulative_cashflow cc
                    ON pp.product_id = cc.product_id AND cc."timestamp" <= pp.bucket
        )
        WHERE row_number = 1 AND user_id IS NOT NULL

        -- Query 4: If include_realtime=true, get real-time price updates (non-bucketed) after the view watermark
        {% if g.include_realtime %}
            UNION ALL

            SELECT user_id, product_id, "timestamp", units_held, net_investment, deposits,
                   withdrawals, fees, buy_units, sell_units, buy_cost, sell_proceeds,
                   market_price * units_held AS market_value
            FROM (
                SELECT cc.user_id, cc.product_id, pp."timestamp", cc.units_held, cc.net_investment,
                       cc.deposits, cc.withdrawals, cc.fees, cc.buy_units, cc.sell_units,
                       cc.buy_cost, cc.sell_proceeds, pp.price AS market_price,
                       ROW_NUMBER() OVER (PARTITION BY pp.product_id, pp."timestamp", cc.user_id
                                          ORDER BY cc."timestamp" DESC) AS row_number
                FROM watermark
                    CROSS JOIN view_watermark
                    INNER JOIN price_update pp
                        ON pp."timestamp" > view_watermark.last_bucketed_timestamp
                        {% if g.cache_retention %}
                            AND pp."timestamp" > NOW() - INTERVAL '{{ g.cache_retention }}'
                        {% else %}
                            AND pp."timestamp" > watermark.watermark
                        {% endif %}
                    LEFT OUTER JOIN cumulative_cashflow cc
                        ON pp.product_id = cc.product_id AND cc."timestamp" <= pp."timestamp"
            )
            WHERE row_number = 1 AND user_id IS NOT NULL
        {% endif %}
        ;

{% endfor %}

-- Deletes cache entries for a specific user-product from a given timestamp onwards.
-- Used when cumulative_cashflow_cache changes (out-of-order cashflows or cache refresh).
CREATE OR REPLACE FUNCTION invalidate_user_product_timeline_cache(
    p_user_id UUID, p_product_id UUID, p_from_timestamp TIMESTAMPTZ
)
RETURNS void AS $$
BEGIN
    -- Delete cache entries for the specified user-product at or after the threshold
    -- Do this for all granularities
    {% for g in GRANULARITIES %}

        DELETE FROM user_product_timeline_cache_{{ g.suffix }}
        WHERE user_id = p_user_id AND product_id = p_product_id AND "timestamp" >= p_from_timestamp;

    {% endfor %}
END;
$$ LANGUAGE plpgsql;


-- Repair cache for a specific user-product and granularity (repair gaps after invalidation)
CREATE OR REPLACE FUNCTION repair_user_product_timeline(p_user_id UUID, p_product_id UUID)
    RETURNS void AS $$
    DECLARE v_user_product_watermark TIMESTAMPTZ;
            v_overall_watermark TIMESTAMPTZ;
            v_repair_start TIMESTAMPTZ;
            v_retention_cutoff TIMESTAMPTZ;
    BEGIN
        {% for g in GRANULARITIES %}

            -- Find the overall cache watermark (largest cached timestamp across ALL user-products)
            SELECT MAX("timestamp")
            INTO v_overall_watermark
            FROM user_product_timeline_cache_{{ g.suffix }};

            -- If no cache exists at all (never been refreshed), nothing to repair - exit
            IF v_overall_watermark IS NULL THEN
                RETURN;
            END IF;

            -- Find the last cached timestamp for this specific user-product
            SELECT MAX("timestamp")
            INTO v_user_product_watermark
            FROM user_product_timeline_cache_{{ g.suffix }}
            WHERE user_id = p_user_id
            AND product_id = p_product_id;

            -- Calculate repair start time (respects retention for granularities with retention)
            {% if g.cache_retention %}
            v_retention_cutoff := NOW() - INTERVAL '{{ g.cache_retention }}';
            v_repair_start := GREATEST(
                COALESCE(v_user_product_watermark, '-infinity'::timestamptz),
                v_retention_cutoff
            );
            {% else %}
            v_repair_start := COALESCE(v_user_product_watermark, '-infinity'::timestamptz);
            {% endif %}

            -- Insert rows from (v_repair_start, v_overall_watermark] to repair the gap
            INSERT INTO user_product_timeline_cache_{{ g.suffix }} (
                user_id, product_id, "timestamp", units_held, net_investment, deposits,
                withdrawals, fees, buy_units, sell_units, buy_cost,
                sell_proceeds, market_value
            )
            SELECT user_id, product_id, "timestamp", units_held, net_investment, deposits,
                withdrawals, fees, buy_units, sell_units, buy_cost,
                sell_proceeds, market_value
            FROM user_product_timeline_{{ g.suffix }}
            WHERE user_id = p_user_id AND
                product_id = p_product_id AND
                "timestamp" > v_repair_start AND
                "timestamp" <= v_overall_watermark;

        {% endfor %}
    END;
    $$ LANGUAGE plpgsql;


-- Refresh cache for all user-products and granularity (move watermark forward)
{% for g in GRANULARITIES %}

    -- IMPORTANT: After calling this function, run:
    --   VACUUM ANALYZE user_product_timeline_cache_{{ g.suffix }};
    -- This updates the visibility map for efficient index-only scans on the watermark
    CREATE OR REPLACE FUNCTION refresh_user_product_timeline_{{ g.suffix }}()
    RETURNS void AS $$
    DECLARE v_overall_watermark TIMESTAMPTZ;
            v_retention_cutoff TIMESTAMPTZ;
    BEGIN
        -- Find the overall cache watermark (largest cached timestamp)
        SELECT MAX("timestamp")
        INTO v_overall_watermark
        FROM user_product_timeline_cache_{{ g.suffix }};

        -- Insert all rows after watermark (for all user-products)
        -- If watermark is NULL, fills everything from the beginning
        -- Reads from cumulative_cashflow_cache (assumes it's refreshed first)
        INSERT INTO user_product_timeline_cache_{{ g.suffix }} (
            user_id, product_id, "timestamp", units_held, net_investment, deposits,
            withdrawals, fees, buy_units, sell_units, buy_cost,
            sell_proceeds, market_value
        )
        SELECT cc.user_id, cc.product_id, cc."timestamp", cc.units_held, cc.net_investment,
            cc.deposits, cc.withdrawals, cc.fees, cc.buy_units, cc.sell_units, cc.buy_cost,
            cc.sell_proceeds, p.market_price * cc.units_held AS market_value
        FROM cumulative_cashflow_cache cc
            LEFT JOIN LATERAL (
                SELECT price AS market_price
                FROM price_update_{{ g.suffix }}
                WHERE price_update_{{ g.suffix }}.product_id = cc.product_id AND
                    price_update_{{ g.suffix }}.bucket <= cc."timestamp"
                ORDER BY price_update_{{ g.suffix }}.bucket DESC
                LIMIT 1
            ) p ON true
        WHERE v_overall_watermark IS NULL OR  -- No cache exists, fill everything
            cc."timestamp" > v_overall_watermark; -- After watermark

        {% if g.cache_retention %}
        -- Delete old cache entries beyond retention period
        v_retention_cutoff := NOW() - INTERVAL '{{ g.cache_retention }}';
        DELETE FROM user_product_timeline_cache_{{ g.suffix }}
        WHERE "timestamp" < v_retention_cutoff;
        {% endif %}
    END;
    $$ LANGUAGE plpgsql;

{% endfor %}
