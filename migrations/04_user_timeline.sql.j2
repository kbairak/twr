{% for g in GRANULARITIES %}

    CREATE TABLE user_timeline_cache_{{ g.suffix }} (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

        -- Denormalized fields for efficient querying
        user_id UUID NOT NULL,
        "timestamp" TIMESTAMPTZ NOT NULL,

        -- Portfolio-level aggregates (SUM across all products)
        net_investment NUMERIC(20, 6),
        market_value NUMERIC(20, 6),

        -- Aggregated cumulative fields
        deposits NUMERIC(20, 6),
        withdrawals NUMERIC(20, 6),
        fees NUMERIC(20, 6),
        buy_units NUMERIC(20, 6),
        sell_units NUMERIC(20, 6),
        buy_cost NUMERIC(20, 6),
        sell_proceeds NUMERIC(20, 6),
        cost_basis NUMERIC(20, 6),
        sell_basis NUMERIC(20, 6),

        CONSTRAINT unique_user_timeline_{{ g.suffix }} UNIQUE (user_id, "timestamp")
    );

    CREATE INDEX idx_user_timeline_cache_{{ g.suffix }}_user
        ON user_timeline_cache_{{ g.suffix }}(user_id, "timestamp" DESC);
    CREATE INDEX idx_user_timeline_cache_{{ g.suffix }}_timestamp
        ON user_timeline_cache_{{ g.suffix }}("timestamp" DESC);

    CREATE VIEW user_timeline_{{ g.suffix }} AS
        WITH
            -- CTE 1: Find the watermark (last cached timestamp) per user
            cache_watermark AS (
                SELECT user_id, MAX("timestamp") AS last_cached_timestamp
                FROM user_timeline_cache_{{ g.suffix }}
                GROUP BY user_id
            ),

            -- CTE 2: Get all distinct timestamps after watermark where ANY product had an event
            all_timestamps AS (
                SELECT DISTINCT upt.user_id, upt."timestamp"
                FROM user_product_timeline_{{ g.suffix }} upt
                    LEFT JOIN cache_watermark cw ON upt.user_id = cw.user_id
                WHERE {% if g.cache_retention %}
                    -- Only compute fresh data within retention period
                    upt."timestamp" > GREATEST(
                        COALESCE(cw.last_cached_timestamp, '-infinity'::timestamptz),
                        NOW() - INTERVAL '{{ g.cache_retention }}'
                    )
                {% else %}
                    -- Unlimited retention: compute from watermark or beginning
                    cw.last_cached_timestamp IS NULL OR upt."timestamp" > cw.last_cached_timestamp
                {% endif %}
            ),

            -- CTE 3: For each timestamp, get the latest state of each product
            -- Uses DISTINCT ON to pick the most recent product state at or before each timestamp
            latest_product_state AS (
                SELECT DISTINCT ON (at.user_id, at."timestamp", upt.product_id)
                    at.user_id, at."timestamp", upt.product_id, upt.net_investment,
                    upt.market_value, upt.deposits, upt.withdrawals, upt.fees, upt.buy_units,
                    upt.sell_units, upt.buy_cost, upt.sell_proceeds, upt.units_held
                FROM all_timestamps at
                    JOIN user_product_timeline_{{ g.suffix }} upt
                        ON upt.user_id = at.user_id AND upt."timestamp" <= at."timestamp"
                ORDER BY at.user_id, at."timestamp", upt.product_id, upt."timestamp" DESC
            )

        -- Final: UNION cached + fresh
        SELECT user_id, "timestamp", net_investment, market_value, deposits, withdrawals, fees,
               buy_units, sell_units, buy_cost, sell_proceeds, cost_basis, sell_basis
        FROM user_timeline_cache_{{ g.suffix }}

        UNION ALL

        SELECT user_id, "timestamp", SUM(net_investment) AS net_investment,
               SUM(market_value) AS market_value, SUM(deposits) AS deposits,
               SUM(withdrawals) AS withdrawals, SUM(fees) AS fees, SUM(buy_units) AS buy_units,
               SUM(sell_units) AS sell_units, SUM(buy_cost) AS buy_cost,
               SUM(sell_proceeds) AS sell_proceeds,
               SUM(CASE WHEN buy_units > 0 THEN
                   (buy_cost / buy_units) * units_held
                   ELSE 0 END) AS cost_basis,
               SUM(CASE WHEN buy_units > 0 THEN
                   (buy_cost / buy_units) * sell_units
                   ELSE 0 END) AS sell_basis
        FROM latest_product_state
        GROUP BY user_id, "timestamp";

{% endfor %}

-- Deletes cache entries for a specific user from a given timestamp onwards.
-- Used when user_product_timeline_cache changes.

CREATE OR REPLACE FUNCTION invalidate_user_timeline_cache(
        p_user_id UUID, p_from_timestamp TIMESTAMPTZ
    )
    RETURNS void AS $$
    BEGIN
        -- Delete cache entries for the specified user at or after the threshold
        -- Do this for all granularities
        {% for g in GRANULARITIES %}

            DELETE FROM user_timeline_cache_{{ g.suffix }}
            WHERE user_id = p_user_id
            AND "timestamp" >= p_from_timestamp;

        {% endfor %}
    END;
    $$ LANGUAGE plpgsql;

-- Repair cache for a specific user and granularity (repair gaps after invalidation)
CREATE OR REPLACE FUNCTION repair_user_timeline(p_user_id UUID)
    RETURNS void AS $$
    DECLARE v_user_watermark TIMESTAMPTZ;
            v_overall_watermark TIMESTAMPTZ;
            v_repair_start TIMESTAMPTZ;
            v_retention_cutoff TIMESTAMPTZ;
    BEGIN
        {% for g in GRANULARITIES %}

            -- Find the overall cache watermark (largest cached timestamp across ALL users)
            SELECT MAX("timestamp") INTO v_overall_watermark
            FROM user_timeline_cache_{{ g.suffix }};

            -- If no cache exists at all (never been refreshed), nothing to repair - exit
            IF v_overall_watermark IS NULL THEN
                RETURN;
            END IF;

            -- Find the last cached timestamp for this specific user
            SELECT MAX("timestamp") INTO v_user_watermark
            FROM user_timeline_cache_{{ g.suffix }}
            WHERE user_id = p_user_id;

            -- Calculate repair start time (respects retention for granularities with retention)
            {% if g.cache_retention %}
                v_retention_cutoff := NOW() - INTERVAL '{{ g.cache_retention }}';
                v_repair_start := GREATEST(
                    COALESCE(v_user_watermark, '-infinity'::timestamptz),
                    v_retention_cutoff
                );
            {% else %}
                v_repair_start := COALESCE(v_user_watermark, '-infinity'::timestamptz);
            {% endif %}

            -- Insert rows from (v_repair_start, v_overall_watermark] to repair the gap
            INSERT INTO user_timeline_cache_{{ g.suffix }} (
                user_id, "timestamp", net_investment, market_value, deposits,
                withdrawals, fees, buy_units, sell_units, buy_cost,
                sell_proceeds, cost_basis, sell_basis
            )
            SELECT user_id, "timestamp", net_investment, market_value, deposits, withdrawals, fees,
                   buy_units, sell_units, buy_cost, sell_proceeds, cost_basis, sell_basis
            FROM user_timeline_{{ g.suffix }}
            WHERE user_id = p_user_id AND
                  "timestamp" > v_repair_start AND
                  "timestamp" <= v_overall_watermark;

        {% endfor %}
    END;
    $$ LANGUAGE plpgsql;


-- Refresh cache for all users and granularity (move watermark forward)
{% for g in GRANULARITIES %}

    -- IMPORTANT: After calling this function, run:
    --   VACUUM ANALYZE user_timeline_cache_{{ g.suffix }};
    -- This updates the visibility map for efficient index-only scans on the watermark
    CREATE OR REPLACE FUNCTION refresh_user_timeline_{{ g.suffix }}()
        RETURNS void AS $$
        DECLARE v_overall_watermark TIMESTAMPTZ;
                v_retention_cutoff TIMESTAMPTZ;
        BEGIN
            -- Find the overall cache watermark (largest cached timestamp)
            SELECT MAX("timestamp")
            INTO v_overall_watermark
            FROM user_timeline_cache_{{ g.suffix }};

            -- Insert all rows after watermark (for all users)
            -- If watermark is NULL, fills everything from the beginning
            -- Reads from user_product_timeline_cache (assumes it's refreshed first)
            INSERT INTO user_timeline_cache_{{ g.suffix }} (
                user_id, "timestamp", net_investment, market_value, deposits,
                withdrawals, fees, buy_units, sell_units, buy_cost,
                sell_proceeds, cost_basis, sell_basis
            )
            SELECT user_id, "timestamp", SUM(net_investment) AS net_investment,
                   SUM(market_value) AS market_value, SUM(deposits) AS deposits,
                   SUM(withdrawals) AS withdrawals, SUM(fees) AS fees, SUM(buy_units) AS buy_units,
                   SUM(sell_units) AS sell_units, SUM(buy_cost) AS buy_cost,
                   SUM(sell_proceeds) AS sell_proceeds,
                   SUM(CASE WHEN buy_units > 0 THEN
                       (buy_cost / buy_units) * units_held
                       ELSE 0 END) AS cost_basis,
                   SUM(CASE WHEN buy_units > 0 THEN
                       (buy_cost / buy_units) * sell_units
                       ELSE 0 END) AS sell_basis
            FROM user_product_timeline_cache_{{ g.suffix }}
            WHERE v_overall_watermark IS NULL OR -- No cache exists, fill everything
                  "timestamp" > v_overall_watermark -- After watermark
            GROUP BY user_id, "timestamp";

            {% if g.cache_retention %}
                -- Delete old cache entries beyond retention period
                v_retention_cutoff := NOW() - INTERVAL '{{ g.cache_retention }}';
                DELETE FROM user_timeline_cache_{{ g.suffix }}
                WHERE "timestamp" < v_retention_cutoff;
            {% endif %}
        END;
        $$ LANGUAGE plpgsql;

{% endfor %}
