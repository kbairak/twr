CREATE TABLE IF NOT EXISTS cumulative_cashflow_cache (
    -- Denormalized fields from cashflow for efficient querying
    user_id        UUID NOT NULL,
    product_id     UUID NOT NULL,
    "timestamp"    TIMESTAMPTZ NOT NULL,

    -- Monotonic totals - units (always increasing)
    buy_units     NUMERIC(20, 6),  -- Σ(units_delta)       for buys only
    sell_units    NUMERIC(20, 6),  -- Σ(|units_delta|)     for sells only

    -- Monotonic totals - execution_money (always increasing)
    buy_cost      NUMERIC(20, 6),  -- Σ(execution_money)   for buys
    sell_proceeds NUMERIC(20, 6),  -- Σ(|execution_money|) for sells

    -- Monotonic totals - cash flows (always increasing)
    deposits      NUMERIC(20, 6),  -- Σ(user_money)        for buys (what left bank)
    withdrawals   NUMERIC(20, 6)   -- Σ(|user_money|)      for sells (what entered bank)

    -- We can derive:
    --   - units          = buy_units - sell_units
    --   - net_investment = deposits  - withdrawals
    --   - fees           = deposits  - buy_cost + withdrawals - sell_proceeds
    --   - avg_buy_cost   = buy_cost  / buy_units
    --   - cost_basis     = units     × avg_buy_cost
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_cumulative_cashflow_cache_user_product_ts
    ON cumulative_cashflow_cache(user_id, product_id, "timestamp" DESC);
CREATE INDEX IF NOT EXISTS idx_cumulative_cashflow_cache_user_ts
    ON cumulative_cashflow_cache(user_id, "timestamp" DESC);
CREATE INDEX IF NOT EXISTS idx_cumulative_cashflow_cache_product
    ON cumulative_cashflow_cache(product_id, "timestamp" DESC);
CREATE INDEX IF NOT EXISTS idx_cumulative_cashflow_cache_timestamp
    ON cumulative_cashflow_cache("timestamp" DESC);

-- _seed_cf: Returns the most recent cached cumulative cashflow for each (user, product) pair
--
-- Purpose: Serves as a starting point to avoid recalculating from the beginning of time
-- Returns: Latest row from cumulative_cashflow_cache for matching user/product pairs
-- Performance: O(1) per (user, product) pair due to DISTINCT ON with DESC index
-- Parameters:
--   - p_user_id: Filter by user (NULL = all users)
--   - p_product_id: Filter by product (NULL = all products)
CREATE OR REPLACE FUNCTION _seed_cf(p_user_id UUID DEFAULT NULL, p_product_id UUID DEFAULT NULL)
    RETURNS TABLE (
        user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ, buy_units NUMERIC(20, 6),
        sell_units NUMERIC(20, 6), buy_cost NUMERIC(20, 6), sell_proceeds NUMERIC(20, 6),
        deposits NUMERIC(20, 6), withdrawals NUMERIC(20, 6)
    )
    LANGUAGE plpgsql STABLE AS $$
    BEGIN
        {% macro query(filter_user, filter_product) %}
            RETURN QUERY
            SELECT DISTINCT ON (ccfc.user_id, ccfc.product_id)
                ccfc.user_id, ccfc.product_id, ccfc."timestamp", ccfc.buy_units, ccfc.sell_units,
                ccfc.buy_cost, ccfc.sell_proceeds, ccfc.deposits, ccfc.withdrawals
            FROM cumulative_cashflow_cache ccfc
            WHERE
                TRUE
                {% if filter_user %}    AND ccfc.user_id    = p_user_id   {% endif %}
                {% if filter_product %} AND ccfc.product_id = p_product_id{% endif %}
            ORDER BY ccfc.user_id, ccfc.product_id, ccfc."timestamp" DESC
        {% endmacro %}

        {% for fu, fp in itertools.product([True, False], repeat=2) %}
            {% if loop.first %}IF{% else %}ELSIF{% endif %}
                p_user_id    IS {% if fu %}NOT{% endif %} NULL AND
                p_product_id IS {% if fp %}NOT{% endif %} NULL
            THEN
                {{ query(filter_user=fu, filter_product=fp) }};
        {% endfor %}
        END IF;
    END;
    $$;

-- _fresh_cf: Returns new cashflow events that haven't been cached yet
--
-- Purpose: Gets cashflows newer than the latest cached entry (seed)
-- Returns: Aggregated cashflows grouped by (user, product, timestamp)
-- Performance: Scans cashflow table from seed timestamp onward
-- Note: Joins with _seed_cf to determine the watermark for each (user, product)
-- Parameters:
--   - p_user_id, p_product_id: Filter by user/product (NULL = all)
--   - p_before: Only return rows before or at this timestamp (NULL = no upper bound)
CREATE OR REPLACE FUNCTION _fresh_cf(
        p_user_id    UUID        DEFAULT NULL,
        p_product_id UUID        DEFAULT NULL,
        p_before     TIMESTAMPTZ DEFAULT NULL
    )
    RETURNS TABLE (
        user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ,
        seed_buy_units NUMERIC(20, 6), seed_sell_units NUMERIC(20, 6),
        seed_buy_cost NUMERIC(20, 6), seed_sell_proceeds NUMERIC(20, 6),
        seed_deposits NUMERIC(20, 6), seed_withdrawals NUMERIC(20, 6),
        buy_units NUMERIC(20, 6), sell_units NUMERIC(20, 6), buy_cost NUMERIC(20, 6),
        sell_proceeds NUMERIC(20, 6), deposits NUMERIC(20, 6), withdrawals NUMERIC(20, 6)
    )
    LANGUAGE plpgsql STABLE AS $$
    BEGIN
        {% macro query(filter_user, filter_product, filter_before) %}
            RETURN QUERY
            SELECT
                cf.user_id,
                cf.product_id,
                cf."timestamp",

                -- seed_cf fields
                COALESCE(seed_cf.buy_units, 0) AS seed_buy_units,
                COALESCE(seed_cf.sell_units, 0) AS seed_sell_units,
                COALESCE(seed_cf.buy_cost, 0) AS seed_buy_cost,
                COALESCE(seed_cf.sell_proceeds, 0) AS seed_sell_proceeds,
                COALESCE(seed_cf.deposits, 0) AS seed_deposits,
                COALESCE(seed_cf.withdrawals, 0) AS seed_withdrawals,

                -- Aggregate buy and sell components separately
                SUM(CASE WHEN cf.units_delta > 0 THEN cf.units_delta ELSE 0 END) AS buy_units,
                SUM(CASE WHEN cf.units_delta < 0 THEN -cf.units_delta ELSE 0 END) AS sell_units,
                SUM(CASE WHEN cf.units_delta > 0 THEN cf.units_delta * cf.execution_price ELSE 0 END) AS buy_cost,
                SUM(CASE WHEN cf.units_delta < 0 THEN -cf.units_delta * cf.execution_price ELSE 0 END) AS sell_proceeds,
                SUM(CASE WHEN cf.units_delta > 0 THEN cf.user_money ELSE 0 END) AS deposits,
                SUM(CASE WHEN cf.units_delta < 0 THEN -cf.user_money ELSE 0 END) AS withdrawals
            FROM cashflow cf
                LEFT OUTER JOIN _seed_cf(p_user_id, p_product_id) seed_cf
                    ON cf.user_id = seed_cf.user_id AND cf.product_id = seed_cf.product_id
            WHERE
                (seed_cf."timestamp" IS NULL OR cf."timestamp" > seed_cf."timestamp")
                {% if filter_user %}    AND cf.user_id     = p_user_id   {% endif %}
                {% if filter_product %} AND cf.product_id  = p_product_id{% endif %}
                {% if filter_before %}  AND cf."timestamp" <= p_before   {% endif %}
            GROUP BY
                cf.user_id, cf.product_id, cf."timestamp",
                seed_cf.buy_units, seed_cf.sell_units, seed_cf.buy_cost, seed_cf.sell_proceeds,
                seed_cf.deposits, seed_cf.withdrawals
        {% endmacro %}

        {% for fu, fp, fb in itertools.product([True, False], repeat=3) %}
            {% if loop.first %}IF{% else %}ELSIF{% endif %}
                p_user_id    IS {% if fu %} NOT {% endif %} NULL AND
                p_product_id IS {% if fp %} NOT {% endif %} NULL AND
                p_before     IS {% if fb %} NOT {% endif %} NULL
            THEN
                {{ query(filter_user=fu, filter_product=fp, filter_before=fb) }};
        {% endfor %}
        END IF;
    END;
    $$;

-- cumulative_cashflow: Returns running totals of cashflows (cached + fresh)
--
-- Purpose: Main query interface for cumulative cashflow data
-- Returns: Union of cached data + computed running totals from fresh cashflows
-- Performance:
--   - Cached portion: Index lookup
--   - Fresh portion: Window function over uncached rows only
-- Parameters:
--   - p_user_id, p_product_id: Filter by user/product (NULL = all)
--   - p_after: Only return rows after this timestamp (NULL = no lower bound)
--   - p_before: Only return rows before or at this timestamp (NULL = no upper bound)

CREATE OR REPLACE FUNCTION cumulative_cashflow(
        p_user_id    UUID        DEFAULT NULL,
        p_product_id UUID        DEFAULT NULL,
        p_after      TIMESTAMPTZ DEFAULT NULL,
        p_before     TIMESTAMPTZ DEFAULT NULL
    )
    RETURNS TABLE (
        user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ, buy_units NUMERIC(20, 6),
        sell_units NUMERIC(20, 6), buy_cost NUMERIC(20, 6), sell_proceeds NUMERIC(20, 6),
        deposits NUMERIC(20, 6), withdrawals NUMERIC(20, 6)
    )
    LANGUAGE plpgsql STABLE AS $$
    BEGIN
        {% macro query(filter_user, filter_product, filter_after, filter_before) %}
            RETURN QUERY
            SELECT
                ccfc.user_id, ccfc.product_id, ccfc."timestamp", ccfc.buy_units, ccfc.sell_units,
                ccfc.buy_cost, ccfc.sell_proceeds, ccfc.deposits, ccfc.withdrawals
            FROM cumulative_cashflow_cache ccfc
            WHERE
                TRUE
                {% if filter_user %}    AND ccfc.user_id     =  p_user_id   {% endif %}
                {% if filter_product %} AND ccfc.product_id  =  p_product_id{% endif %}
                {% if filter_after %}   AND ccfc."timestamp" >  p_after     {% endif %}
                {% if filter_before %}  AND ccfc."timestamp" <= p_before    {% endif %}

            UNION ALL

            SELECT *
            FROM (
                SELECT
                    fresh_cf.user_id, fresh_cf.product_id, fresh_cf."timestamp",
                    fresh_cf.seed_buy_units + SUM(fresh_cf.buy_units) OVER w AS buy_units,
                    fresh_cf.seed_sell_units + SUM(fresh_cf.sell_units) OVER w AS sell_units,
                    fresh_cf.seed_buy_cost + SUM(fresh_cf.buy_cost) OVER w AS buy_cost,
                    fresh_cf.seed_sell_proceeds + SUM(fresh_cf.sell_proceeds) OVER w AS sell_proceeds,
                    fresh_cf.seed_deposits + SUM(fresh_cf.deposits) OVER w AS deposits,
                    fresh_cf.seed_withdrawals + SUM(fresh_cf.withdrawals) OVER w AS withdrawals
                FROM _fresh_cf(p_user_id, p_product_id, p_before) fresh_cf
                WINDOW w AS (
                    PARTITION BY fresh_cf.user_id, fresh_cf.product_id
                    ORDER BY fresh_cf."timestamp"
                )
            ) AS computed_fresh
            {% if filter_after %}WHERE computed_fresh."timestamp" > p_after{% endif %}
        {% endmacro %}

        {% for fu, fp, fa, fb in itertools.product([True, False], repeat=4) %}
            {% if loop.first %}IF{% else %}ELSIF{% endif %}
                p_user_id    IS {% if fu %} NOT {% endif %} NULL AND
                p_product_id IS {% if fp %} NOT {% endif %} NULL AND
                p_after      IS {% if fa %} NOT {% endif %} NULL AND
                p_before     IS {% if fb %} NOT {% endif %} NULL
            THEN
                {{ query(filter_user=fu, filter_product=fp, filter_after=fa, filter_before=fb) }};
        {% endfor %}
        END IF;
    END;
    $$;

-- refresh_cumulative_cashflow: Updates the cumulative_cashflow_cache table
--
-- Purpose: Materialization job to move computed cashflows into cache
-- Side effects: Inserts new rows into cumulative_cashflow_cache
-- Performance: Processes data in 1-day chunks to limit memory usage with ANALYZE after each
-- Usage: Call periodically (e.g., every 5 minutes) to keep cache up-to-date
CREATE OR REPLACE FUNCTION refresh_cumulative_cashflow()
    RETURNS void
    LANGUAGE plpgsql VOLATILE AS $$
    DECLARE
        v_watermark     TIMESTAMPTZ;  -- Last cached cashflow timestamp
        v_max_timestamp TIMESTAMPTZ;  -- Most recent cashflow timestamp, update cache up to this point
    BEGIN
        -- Get the maximum timestamp from source data
        SELECT MAX("timestamp") INTO v_max_timestamp
        FROM cashflow;

        -- Exit if no cashflows exist
        IF v_max_timestamp IS NULL THEN
            RETURN;
        END IF;

        -- Get current watermark
        SELECT MAX("timestamp") INTO v_watermark
        FROM cumulative_cashflow_cache;

        -- If no watermark, initialize from oldest cashflow - 1ms
        IF v_watermark IS NULL THEN
            SELECT MIN("timestamp") - INTERVAL '1 millisecond' INTO v_watermark
            FROM cashflow;
        END IF;

        LOOP
            -- Exit if watermark has reached the end
            EXIT WHEN v_watermark >= v_max_timestamp;

            -- Insert one day's worth of data (or up to max_timestamp if less than a day remains)
            INSERT INTO cumulative_cashflow_cache (
                user_id, product_id, "timestamp", buy_units, sell_units, buy_cost, sell_proceeds,
                deposits, withdrawals
            )
            SELECT
                ccf.user_id, ccf.product_id, ccf."timestamp", ccf.buy_units, ccf.sell_units,
                ccf.buy_cost, ccf.sell_proceeds, ccf.deposits, ccf.withdrawals
            FROM cumulative_cashflow(NULL, NULL, v_watermark, LEAST(v_watermark + INTERVAL '1 day', v_max_timestamp)) ccf;

            -- Advance watermark by the range we just tried (not by what was inserted)
            v_watermark := LEAST(v_watermark + INTERVAL '1 day', v_max_timestamp);

            -- Update statistics after each chunk to help query planner (autovacuum handles bloat)
            ANALYZE cumulative_cashflow_cache;
        END LOOP;
    END;
    $$;
