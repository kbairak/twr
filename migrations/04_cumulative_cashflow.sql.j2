CREATE TABLE cumulative_cashflow_cache (
    -- Denormalized fields from cashflow for efficient querying
    user_id UUID NOT NULL,
    product_id UUID NOT NULL,
    "timestamp" TIMESTAMPTZ NOT NULL,

    -- Monotonic totals - units (always increasing)
    buy_units NUMERIC(20, 6),         -- Σ(units_delta) for buys only
    sell_units NUMERIC(20, 6),        -- Σ(|units_delta|) for sells only

    -- Monotonic totals - execution_money (always increasing)
    buy_cost NUMERIC(20, 6),          -- Σ(execution_money) for buys
    sell_proceeds NUMERIC(20, 6),     -- Σ(|execution_money|) for sells

    -- Monotonic totals - cash flows (always increasing)
    deposits NUMERIC(20, 6),          -- Σ(user_money) for buys (what left bank)
    withdrawals NUMERIC(20, 6),       -- Σ(|user_money|) for sells (what entered bank)

    -- We can derive:
    --   - units = buy_units - sell_units
    --   - net_investment = deposits - withdrawals
    --   - fees = deposits - buy_cost + withdrawals - sell_proceeds

    CONSTRAINT unique_cashflow UNIQUE (user_id, product_id, "timestamp")
);

CREATE UNIQUE INDEX idx_cumulative_cashflow_cache_user_product
    ON cumulative_cashflow_cache(user_id, product_id, "timestamp" DESC);
CREATE INDEX idx_cumulative_cashflow_cache_product
    ON cumulative_cashflow_cache(product_id, "timestamp" DESC);
CREATE INDEX idx_cumulative_cashflow_cache_timestamp
    ON cumulative_cashflow_cache("timestamp" DESC);

CREATE FUNCTION seed_cf(p_user_id UUID, p_product_id UUID)
    RETURNS TABLE (
        user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ, buy_units NUMERIC(20, 6),
        sell_units NUMERIC(20, 6), buy_cost NUMERIC(20, 6), sell_proceeds NUMERIC(20, 6),
        deposits NUMERIC(20, 6), withdrawals NUMERIC(20, 6)
    )
    LANGUAGE plpgsql STABLE AS $$
    BEGIN
        {% macro query(w) %}
            RETURN QUERY
            SELECT DISTINCT ON (ccfc.user_id, ccfc.product_id)
                ccfc.user_id, ccfc.product_id, ccfc."timestamp", ccfc.buy_units, ccfc.sell_units,
                ccfc.buy_cost, ccfc.sell_proceeds, ccfc.deposits, ccfc.withdrawals
            FROM cumulative_cashflow_cache ccfc
            {{ w }}
            ORDER BY ccfc.user_id, ccfc.product_id, ccfc."timestamp" DESC
        {% endmacro %}
        IF p_user_id IS NULL AND p_product_id IS NULL THEN
            {{ query() }};
        ELSIF p_user_id IS NOT NULL AND p_product_id IS NULL THEN
            {{ query('WHERE ccfc.user_id = p_user_id') }};
        ELSIF p_user_id IS NULL AND p_product_id IS NOT NULL THEN
            {{ query('WHERE ccfc.product_id = p_product_id') }};
        ELSE
            {{ query('WHERE ccfc.user_id = p_user_id AND ccfc.product_id = p_product_id') }};
        END IF;
    END;
    $$;

CREATE FUNCTION fresh_cf(p_user_id UUID, p_product_id UUID)
    RETURNS TABLE (
        user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ, units_delta NUMERIC(20, 6),
        execution_price NUMERIC(20, 6), user_money NUMERIC(20, 6), execution_money NUMERIC(20, 6)
    )
    LANGUAGE plpgsql STABLE AS $$
    BEGIN
        {% macro query(w) %}
            RETURN QUERY
            SELECT
                cf.user_id, cf.product_id, cf."timestamp",
                SUM(cf.units_delta) AS units_delta,
                (
                    SUM(cf.execution_price * cf.units_delta) / NULLIF(SUM(cf.units_delta), 0)
                ) AS execution_price,
                SUM(cf.user_money) AS user_money,
                -- units_delta * execution_price AS execution_money
                SUM(cf.units_delta) *
                    (SUM(cf.execution_price * cf.units_delta) / NULLIF(SUM(cf.units_delta), 0))
                    AS execution_money
            FROM cashflow cf
                LEFT OUTER JOIN seed_cf(p_user_id, p_product_id) seed_cf
                    ON cf.user_id = seed_cf.user_id AND cf.product_id = seed_cf.product_id
            WHERE (seed_cf."timestamp" IS NULL OR cf."timestamp" > seed_cf."timestamp") {{ w }}
            GROUP BY cf.user_id, cf.product_id, cf."timestamp"
        {% endmacro %}
        IF p_user_id IS NULL AND p_product_id IS NULL THEN
            {{ query() }};
        ELSIF p_user_id IS NOT NULL AND p_product_id IS NULL THEN
            {{ query('AND cf.user_id = p_user_id') }};
        ELSIF p_user_id IS NULL AND p_product_id IS NOT NULL THEN
            {{ query('AND cf.product_id = p_product_id') }};
        ELSE
            {{ query('AND cf.user_id = p_user_id AND cf.product_id = p_product_id') }};
        END IF;
    END;
    $$;

CREATE FUNCTION cumulative_cashflow(
    p_user_id UUID,
    p_product_id UUID,
    p_only_latest BOOLEAN DEFAULT FALSE,
    p_after TIMESTAMPTZ DEFAULT NULL
)
    RETURNS TABLE (
        user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ, buy_units NUMERIC(20, 6),
        sell_units NUMERIC(20, 6), buy_cost NUMERIC(20, 6), sell_proceeds NUMERIC(20, 6),
        deposits NUMERIC(20, 6), withdrawals NUMERIC(20, 6)
    )
    LANGUAGE plpgsql STABLE AS $$
    BEGIN
        {% macro query(w1='', w2='', o='') %}
            RETURN QUERY
            SELECT
                ccfc.user_id, ccfc.product_id, ccfc."timestamp", ccfc.buy_units, ccfc.sell_units,
                ccfc.buy_cost, ccfc.sell_proceeds, ccfc.deposits, ccfc.withdrawals
            FROM cumulative_cashflow_cache ccfc
            {{ w1 }}

            UNION ALL

            SELECT
                fresh_cf.user_id, fresh_cf.product_id, fresh_cf."timestamp",
                COALESCE(seed_cf.buy_units, 0) +
                    SUM(CASE WHEN fresh_cf.units_delta > 0 THEN fresh_cf.units_delta ELSE 0 END)
                    OVER w AS buy_units,
                COALESCE(seed_cf.sell_units, 0) +
                    SUM(CASE WHEN fresh_cf.units_delta < 0 THEN -fresh_cf.units_delta ELSE 0 END)
                    OVER w AS sell_units,
                COALESCE(seed_cf.buy_cost, 0) +
                    SUM(CASE WHEN fresh_cf.units_delta > 0 THEN fresh_cf.execution_money ELSE 0 END)
                    OVER w AS buy_cost,
                COALESCE(seed_cf.sell_proceeds, 0) +
                    SUM(CASE WHEN fresh_cf.units_delta < 0 THEN -fresh_cf.execution_money ELSE 0 END)
                    OVER w AS sell_proceeds,
                COALESCE(seed_cf.deposits, 0) +
                    SUM(CASE WHEN fresh_cf.units_delta > 0 THEN fresh_cf.user_money ELSE 0 END)
                    OVER w AS deposits,
                COALESCE(seed_cf.withdrawals, 0) +
                    SUM(CASE WHEN fresh_cf.units_delta < 0 THEN -fresh_cf.user_money ELSE 0 END)
                    OVER w AS withdrawals
            FROM fresh_cf(p_user_id, p_product_id) fresh_cf
                LEFT OUTER JOIN seed_cf(p_user_id, p_product_id) seed_cf ON
                    fresh_cf.user_id = seed_cf.user_id AND
                    fresh_cf.product_id = seed_cf.product_id
            {{ w2 }}
            WINDOW w AS (
                PARTITION BY fresh_cf.user_id, fresh_cf.product_id
                ORDER BY fresh_cf."timestamp"
                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
            )
            {{ o }}
        {% endmacro %}
        IF p_user_id IS NULL AND p_product_id IS NULL THEN
            {{ query() }};
        ELSIF p_user_id IS NOT NULL AND p_product_id IS NULL THEN
            {{ query('WHERE ccfc.user_id = p_user_id', 'WHERE fresh_cf.user_id = p_user_id') }};
        ELSIF p_user_id IS NULL AND p_product_id IS NOT NULL THEN
            {{ query(
                'WHERE ccfc.product_id = p_product_id',
                'WHERE fresh_cf.product_id = p_product_id'
            ) }};
        ELSIF p_only_latest THEN
            {{ query(
                'WHERE ccfc.user_id = p_user_id AND ccfc.product_id = p_product_id',
                'WHERE fresh_cf.user_id = p_user_id AND fresh_cf.product_id = p_product_id',
                'ORDER BY user_id, product_id, "timestamp" DESC LIMIT 1'
            ) }};
        ELSIF p_after IS NOT NULL THEN
            {{ query(
                'WHERE ccfc.user_id = p_user_id AND ccfc.product_id = p_product_id AND ccfc."timestamp" > p_after',
                'WHERE fresh_cf.user_id = p_user_id AND fresh_cf.product_id = p_product_id AND fresh_cf."timestamp" > p_after'
            ) }};
        ELSE
            {{ query(
                'WHERE ccfc.user_id = p_user_id AND ccfc.product_id = p_product_id',
                'WHERE fresh_cf.user_id = p_user_id AND fresh_cf.product_id = p_product_id'
            ) }};
        END IF;
    END;
    $$;

CREATE OR REPLACE FUNCTION refresh_cumulative_cashflow(p_current_time TIMESTAMPTZ DEFAULT now())
    RETURNS void AS $$
    DECLARE v_watermark TIMESTAMPTZ;
    BEGIN
        SELECT MAX("timestamp") INTO v_watermark
        FROM cumulative_cashflow_cache;

        INSERT INTO cumulative_cashflow_cache (
            user_id, product_id, "timestamp", buy_units, sell_units, buy_cost, sell_proceeds,
            deposits, withdrawals
        )
        SELECT
            ccf.user_id, ccf.product_id, ccf."timestamp", ccf.buy_units, ccf.sell_units,
            ccf.buy_cost, ccf.sell_proceeds, ccf.deposits, ccf.withdrawals
        FROM cumulative_cashflow(NULL, NULL) ccf
        WHERE v_watermark IS NULL OR ccf."timestamp" > v_watermark;
    END;
    $$ LANGUAGE plpgsql;
