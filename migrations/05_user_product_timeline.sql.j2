{% for g in GRANULARITIES %}

    CREATE TABLE IF NOT EXISTS user_product_timeline_cache_{{ g.suffix }} (
        -- Identity
        user_id            UUID NOT NULL,
        product_id         UUID NOT NULL,
        "timestamp"        TIMESTAMPTZ NOT NULL,  -- Price update timestamp for this product

        -- Reference timestamp for point-in-time lookup
        cashflow_timestamp TIMESTAMPTZ NOT NULL   -- Latest cashflow for this user-product at this time
    );

    CREATE UNIQUE INDEX IF NOT EXISTS idx_user_product_timeline_cache_{{ g.suffix }}_user_product_ts
        ON user_product_timeline_cache_{{ g.suffix }}(user_id, product_id, "timestamp" DESC);
    CREATE INDEX IF NOT EXISTS idx_user_product_timeline_cache_{{ g.suffix }}_user_ts
        ON user_product_timeline_cache_{{ g.suffix }}(user_id, "timestamp" DESC);
    CREATE INDEX IF NOT EXISTS idx_user_product_timeline_cache_{{ g.suffix }}_product_ts
        ON user_product_timeline_cache_{{ g.suffix }}(product_id, "timestamp" DESC);
    CREATE INDEX IF NOT EXISTS idx_user_product_timeline_cache_{{ g.suffix }}_ts
        ON user_product_timeline_cache_{{ g.suffix }}("timestamp" DESC);

    -- _fresh_pt_{{ g.suffix }}: Returns new price update timestamps that haven't been cached yet
    --
    -- Purpose: For each price update after the watermark, finds all users with positions
    --          in that product and their latest cashflow timestamp
    -- Returns: (user_id, product_id, price_timestamp, cashflow_timestamp) for uncached entries
    -- Performance: Uses cumulative_cashflow_cache for efficient latest-cashflow lookups
    -- Parameters:
    --   - p_user_id: Filter by user (NULL = all users)
    --   - p_product_id: Filter by product (NULL = all products)
    --   - p_after: Only return timestamps after this point (required - typically watermark)
    --   - p_before: Only return timestamps before or at this point (NULL = no upper bound)
    CREATE OR REPLACE FUNCTION _fresh_price_update_{{ g.suffix }} (
            p_user_id UUID, p_product_id UUID, p_after TIMESTAMPTZ, p_before TIMESTAMPTZ
        )
        RETURNS TABLE (product_id UUID, "timestamp" TIMESTAMPTZ)
        LANGUAGE plpgsql STABLE AS $$
        BEGIN
            {% macro query(filter_user, filter_product, filter_after, filter_before) %}
                RETURN QUERY
                WITH seed_pu AS (
                    SELECT DISTINCT ON (uptc.product_id) uptc.product_id, uptc."timestamp"
                    FROM user_product_timeline_cache_{{ g.suffix }} uptc
                    WHERE
                        TRUE
                        {% if filter_user %}    AND uptc.user_id    = p_user_id    {% endif %}
                        {% if filter_product %} AND uptc.product_id = p_product_id {% endif %}
                    ORDER BY uptc.product_id, uptc."timestamp" DESC
                )

                SELECT pu.product_id, pu."timestamp"
                FROM price_update_{{ g.suffix }} pu
                    LEFT JOIN seed_pu ON pu.product_id = seed_pu.product_id
                WHERE
                    (seed_pu."timestamp" IS NULL OR pu."timestamp" > seed_pu."timestamp")
                    {% if filter_product %} AND pu.product_id  =  p_product_id {% endif %}
                    {% if filter_after %}   AND pu."timestamp" >= p_after      {% endif %}
                    {% if filter_before %}  AND pu."timestamp" <  p_before     {% endif %}
            {% endmacro %}

            {% for fu, fp, fa, fb in itertools.product([False, True], repeat=4) %}
                {% if loop.first %}IF{% else %}ELSIF{% endif %}
                    p_user_id    IS {% if fu %}NOT{% endif %} NULL AND
                    p_product_id IS {% if fp %}NOT{% endif %} NULL AND
                    p_after      IS {% if fa %}NOT{% endif %} NULL AND
                    p_before     IS {% if fb %}NOT{% endif %} NULL
                THEN
                    {{ query(filter_user=fu, filter_product=fp, filter_after=fa, filter_before=fb) }};
            {% endfor %}
            END IF;
        END;
        $$;

    -- user_product_timeline_{{ g.suffix }}: Returns timeline of (user, product, price_timestamp, cashflow_timestamp)
    --
    -- Purpose: Main query interface for user-product timeline at {{ g.suffix }} granularity
    -- Returns: Union of cached data + fresh price updates with their associated cashflow timestamps
    -- Performance: Cached portion is fast; fresh portion uses LATERAL join to find latest cashflow
    -- Note: Cache retention enforced at deletion time, not query time
    -- Parameters:
    --   - p_user_id: Filter by user (NULL = all users)
    --   - p_product_id: Filter by product (NULL = all products)
    --   - p_after: Only return timestamps after this point (NULL = no lower bound)
    --   - p_before: Only return timestamps before or at this point (NULL = no upper bound)
    CREATE OR REPLACE FUNCTION user_product_timeline_{{ g.suffix }} (
            p_user_id    UUID        DEFAULT NULL,
            p_product_id UUID        DEFAULT NULL,
            p_after      TIMESTAMPTZ DEFAULT NULL,
            p_before     TIMESTAMPTZ DEFAULT NULL
        )
        RETURNS TABLE (
            user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ,
            cashflow_timestamp TIMESTAMPTZ
        )
        LANGUAGE plpgsql STABLE AS $$
        BEGIN
            {% macro query(filter_user, filter_product, filter_after, filter_before) %}
                RETURN QUERY
                WITH ccfm AS MATERIALIZED (
                    SELECT ccf.user_id, ccf.product_id, ccf."timestamp"
                    FROM cumulative_cashflow(p_user_id, p_product_id, NULL, p_before) ccf
                )

                SELECT uptc.user_id, uptc.product_id, uptc."timestamp", uptc.cashflow_timestamp
                FROM user_product_timeline_cache_{{ g.suffix }} uptc
                WHERE
                    TRUE
                    {% if filter_user %}    AND uptc.user_id     =  p_user_id    {% endif %}
                    {% if filter_product %} AND uptc.product_id  =  p_product_id {% endif %}
                    {% if filter_after %}   AND uptc."timestamp" >= p_after      {% endif %}
                    {% if filter_before %}  AND uptc."timestamp" <  p_before     {% endif %}

                UNION ALL

                SELECT
                    ccf.user_id, pu.product_id, pu."timestamp",
                    ccf."timestamp" AS cashflow_timestamp
                FROM _fresh_price_update_{{ g.suffix }}(p_user_id, p_product_id, p_after, p_before) pu
                    CROSS JOIN LATERAL (
                        SELECT DISTINCT ON (ccfm.user_id) ccfm.user_id, ccfm."timestamp"
                        FROM ccfm
                        WHERE
                            ccfm.product_id = pu.product_id AND
                            ccfm."timestamp" <= pu."timestamp"
                        ORDER BY ccfm.user_id, ccfm."timestamp" DESC
                    ) AS ccf
            {% endmacro %}

            {% for fu, fp, fa, fb in itertools.product([False, True], repeat=4) %}
                {% if loop.first %}IF{% else %}ELSIF{% endif %}
                    p_user_id    IS {% if fu %}NOT{% endif %} NULL AND
                    p_product_id IS {% if fp %}NOT{% endif %} NULL AND
                    p_after      IS {% if fa %}NOT{% endif %} NULL AND
                    p_before     IS {% if fb %}NOT{% endif %} NULL
                THEN
                    {{ query(filter_user=fu, filter_product=fp, filter_after=fa, filter_before=fb) }};
            {% endfor %}
            END IF;
        END;
        $$;

    -- refresh_user_product_timeline_{{ g.suffix }}: Updates the timeline cache and enforces retention
    --
    -- Purpose: Materialization job to move computed timelines into cache
    -- Side effects: Inserts new rows and deletes old rows (if retention policy applies)
    -- Performance: Processes data in 1-day chunks to limit memory usage
    -- Usage: Call periodically to keep cache up-to-date
    CREATE OR REPLACE FUNCTION refresh_user_product_timeline_{{ g.suffix }}()
        RETURNS void
        LANGUAGE plpgsql VOLATILE AS $$
        DECLARE
            v_watermark     TIMESTAMPTZ;  -- Last cached timestamp
            v_max_timestamp TIMESTAMPTZ;  -- Most recent price update timestamp
            {% if g.cache_retention %}
            v_retention_start TIMESTAMPTZ;  -- Earliest timestamp to cache (retention boundary)
            {% endif %}
        BEGIN
            -- Get the maximum timestamp from source data
            SELECT MAX("timestamp") INTO v_max_timestamp
            FROM price_update_{{ g.suffix }};

            -- Exit if no price updates exist
            IF v_max_timestamp IS NULL THEN
                RETURN;
            END IF;

            {% if g.cache_retention %}
            -- Calculate retention boundary (only cache data within retention window + 1 day buffer)
            v_retention_start := NOW() - INTERVAL '{{ g.cache_retention }}' - INTERVAL '1 day';
            {% endif %}

            -- Get current watermark
            SELECT MAX("timestamp") INTO v_watermark
            FROM user_product_timeline_cache_{{ g.suffix }};

            -- If no watermark, initialize based on retention policy
            IF v_watermark IS NULL THEN
                {% if g.cache_retention %}
                    -- With retention: only cache data within retention window
                    v_watermark := GREATEST(
                        v_retention_start,
                        (SELECT MIN("timestamp") - INTERVAL '1 millisecond' FROM price_update_{{ g.suffix }})
                    );
                {% else %}
                    -- No retention: cache from beginning of time
                    SELECT MIN("timestamp") - INTERVAL '1 millisecond' INTO v_watermark
                    FROM price_update_{{ g.suffix }};
                {% endif %}
            END IF;

            LOOP
                -- Exit if watermark has reached the end
                EXIT WHEN v_watermark >= v_max_timestamp;

                -- Insert one day's worth of data (or up to max_timestamp if less than a day remains)
                INSERT INTO user_product_timeline_cache_{{ g.suffix }} (
                    user_id, product_id, "timestamp", cashflow_timestamp
                )
                SELECT user_id, product_id, "timestamp", cashflow_timestamp
                FROM user_product_timeline_{{ g.suffix }}(
                    NULL,
                    NULL,
                    v_watermark,
                    LEAST(v_watermark + INTERVAL '1 day', v_max_timestamp)
                );

                -- Advance watermark by the range we just tried (not by what was inserted)
                v_watermark := LEAST(v_watermark + INTERVAL '1 day', v_max_timestamp);
            END LOOP;

            {% if g.cache_retention %}
            -- Delete old cached data beyond retention boundary, but keep at least one row
            -- per (user, product) pair for seed values when querying retention window start
            DELETE FROM user_product_timeline_cache_{{ g.suffix }} upt
            WHERE
                upt."timestamp" < NOW() - INTERVAL '{{ g.cache_retention }}';
            {% endif %}
        END;
        $$;

{% endfor %}
