{% for g in GRANULARITIES %}

    CREATE TABLE user_product_timeline_cache_{{ g.suffix }} (
        -- Identity
        user_id UUID NOT NULL,
        product_id UUID NOT NULL,
        "timestamp" TIMESTAMPTZ NOT NULL,

        -- Previous cumulative cashflow's timestamp, can be used in a JOIN to get more information
        -- for that point in time
        cashflow_timestamp TIMESTAMPTZ NOT NULL,

        CONSTRAINT unique_user_product_timeline{{ g.suffix }} UNIQUE (
            user_id, product_id, "timestamp"
        )
    );

    CREATE INDEX idx_user_product_timeline_cache_{{ g.suffix }}_user_product
        ON user_product_timeline_cache_{{ g.suffix }}(user_id, product_id, "timestamp" DESC);
    CREATE INDEX idx_product_timeline_cache_{{ g.suffix }}_user_product
        ON user_product_timeline_cache_{{ g.suffix }}(product_id, "timestamp" DESC);
    CREATE INDEX idx_user_product_timeline_cache_{{ g.suffix }}_timestamp
        ON user_product_timeline_cache_{{ g.suffix }}("timestamp" DESC);

    CREATE FUNCTION seed_pt_{{ g.suffix }}(p_product_id UUID)
        RETURNS TABLE(product_id UUID, "timestamp" TIMESTAMPTZ)
        LANGUAGE plpgsql STABLE AS $$
        BEGIN
            {% macro query(w='') %}
                RETURN QUERY
                SELECT DISTINCT ON (uptc.product_id) uptc.product_id, uptc."timestamp"
                FROM user_product_timeline_cache_{{ g.suffix }} uptc
                {{ w }}
                ORDER BY uptc.product_id, uptc."timestamp" DESC
            {% endmacro %}
            IF p_product_id IS NULL THEN
                {{ query() }};
            ELSE
                {{ query('WHERE uptc.product_id = p_product_id') }};
            END IF;
        END;
        $$;

    CREATE FUNCTION fresh_pu_{{ g.suffix }}(p_product_id UUID, p_after TIMESTAMPTZ)
        RETURNS TABLE(product_id UUID, "timestamp" TIMESTAMPTZ)
        LANGUAGE plpgsql STABLE AS $$
        BEGIN
            {% macro query(w='') %}
                RETURN QUERY
                SELECT pu.product_id, pu."timestamp"
                FROM price_update_{{ g.suffix }} pu
                    LEFT OUTER JOIN seed_pt_{{ g.suffix }}(p_product_id) seed_pt
                        ON pu.product_id = seed_pt.product_id
                WHERE (seed_pt."timestamp" IS NULL OR pu."timestamp" > seed_pt."timestamp") {{ w }}
            {% endmacro %}
            IF p_product_id IS NULL AND p_after IS NULL THEN
                {{ query() }};
            ELSIF p_product_id IS NOT NULL AND p_after IS NULL THEN
                {{ query('AND pu.product_id = p_product_id') }};
            ELSIF p_product_id IS NULL AND p_after IS NOT NULL THEN
                {{ query('AND pu."timestamp" > p_after') }};
            ELSIF p_product_id IS NOT NULL AND p_after IS NOT NULL THEN
                {{ query('AND pu.product_id = p_product_id AND pu."timestamp" > p_after') }};
            END IF;
        END;
        $$;

    CREATE FUNCTION user_product_timeline_{{ g.suffix }}(
        p_user_id UUID, p_product_id UUID, p_now TIMESTAMPTZ DEFAULT NOW()
    )
        RETURNS TABLE(
            user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ, cashflow_timestamp TIMESTAMPTZ
        )
        LANGUAGE plpgsql STABLE AS $$
        DECLARE
            v_retention_period_start TIMESTAMPTZ;
        BEGIN
            {% if g.cache_retention %}
                v_retention_period_start := p_now - '{{ g.cache_retention }}'::interval;
            {% endif %}
            {% macro query(w1='', w2='') %}
                RETURN QUERY
                SELECT uptc.user_id, uptc.product_id, uptc."timestamp", uptc.cashflow_timestamp
                FROM user_product_timeline_cache_{{ g.suffix }} uptc
                WHERE
                    true  -- Doing this so that the conditional filters can start with AND
                    {{ w1 }}
                    {% if g.cache_retention %}
                        AND uptc."timestamp" >= v_retention_period_start
                    {% endif %}

                UNION ALL

                SELECT
                    latest_ccf.user_id, fresh_pu.product_id, fresh_pu."timestamp",
                    latest_ccf."timestamp" AS cashflow_timestamp
                FROM fresh_pu_{{ g.suffix }}(
                    p_product_id,
                    {% if g.cache_retention %}v_retention_period_start{% else %}NULL{% endif %}
                ) fresh_pu
                    INNER JOIN LATERAL (
                        SELECT DISTINCT ON (ccf.user_id) ccf.user_id, ccf."timestamp"
                        {% if g.cache_retention %}
                            FROM cumulative_cashflow(
                                p_user_id, p_product_id, FALSE, v_retention_period_start
                            ) ccf
                        {% else %}
                            FROM cumulative_cashflow(p_user_id, p_product_id) ccf
                        {% endif %}
                        WHERE
                            ccf.product_id = fresh_pu.product_id AND
                            ccf."timestamp" <= fresh_pu."timestamp"
                        ORDER BY ccf.user_id, ccf."timestamp" DESC
                    ) latest_ccf ON true
                {{ w2 }}
            {% endmacro %}
            IF p_user_id IS NULL AND p_product_id IS NULL THEN
                {{ query() }};
            ELSIF p_user_id IS NOT NULL AND p_product_id IS NULL THEN
                {{ query('AND uptc.user_id = p_user_id') }};
            ELSIF p_user_id IS NULL AND p_product_id IS NOT NULL THEN
                {{ query(
                    'AND uptc.product_id = p_product_id',
                    'WHERE fresh_pu.product_id = p_product_id'
                ) }};
            ELSE
                {{ query(
                    'AND uptc.user_id = p_user_id AND uptc.product_id = p_product_id',
                    'WHERE fresh_pu.product_id = p_product_id'
                ) }};
            END IF;
        END;
        $$;

    CREATE FUNCTION latest_up_{{ g.suffix }}(p_user_id UUID, p_product_id UUID)
        RETURNS TABLE(user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ)
        LANGUAGE plpgsql STABLE AS $$
        BEGIN
            {% macro query(w='') %}
                RETURN QUERY
                SELECT DISTINCT ON (uptc.user_id, uptc.product_id)
                    uptc.user_id, uptc.product_id, uptc."timestamp"
                FROM user_product_timeline_cache_{{ g.suffix }} uptc
                {{ w }}
                ORDER BY uptc.user_id, uptc.product_id, uptc."timestamp" DESC
            {% endmacro %}
            IF p_user_id IS NULL AND p_product_id IS NULL THEN
                {{ query() }};
            ELSIF p_user_id IS NOT NULL AND p_product_id IS NULL THEN
                {{ query('WHERE uptc.user_id = p_user_id') }};
            ELSIF p_user_id IS NULL AND p_product_id IS NOT NULL THEN
                {{ query('WHERE uptc.product_id = p_product_id') }};
            ELSE
                {{ query('WHERE uptc.user_id = p_user_id AND uptc.product_id = p_product_id') }};
            END IF;
        END;
        $$;


    CREATE OR REPLACE FUNCTION refresh_user_product_timeline_{{ g.suffix }}(
        p_now TIMESTAMPTZ DEFAULT NOW()
    )
        RETURNS void AS $$
        DECLARE v_watermark TIMESTAMPTZ;
        BEGIN
            SELECT MAX("timestamp") INTO v_watermark
            FROM user_product_timeline_cache_{{ g.suffix }};

            INSERT INTO user_product_timeline_cache_{{ g.suffix }} (
                user_id, product_id, "timestamp", cashflow_timestamp
            )
            SELECT user_id, product_id, "timestamp", cashflow_timestamp
            FROM user_product_timeline_{{ g.suffix }}(NULL, NULL, p_now)
            WHERE v_watermark IS NULL OR "timestamp" > v_watermark;

            {% if g.cache_retention %}

                -- Delete old rows beyond retention period, but keep at least one row per
                -- user-product
                DELETE FROM user_product_timeline_cache_{{ g.suffix }} upt
                WHERE
                    upt."timestamp" < p_now - INTERVAL '{{ g.cache_retention }}' AND
                    NOT EXISTS (
                        SELECT 1
                        FROM latest_up_{{ g.suffix }}(NULL, NULL) latest_up
                        WHERE
                            latest_up.user_id = upt.user_id AND
                            latest_up.product_id = upt.product_id AND
                            latest_up."timestamp" = upt."timestamp"
                    );

            {% endif %}
        END;
        $$ LANGUAGE plpgsql;

{% endfor %}
