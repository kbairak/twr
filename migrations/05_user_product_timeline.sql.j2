{% for g in GRANULARITIES %}

    CREATE TABLE user_product_timeline_cache_{{ g.suffix }} (
        -- Identity
        user_id UUID NOT NULL,
        product_id UUID NOT NULL,
        "timestamp" TIMESTAMPTZ NOT NULL,

        -- Previous cumulative cashflow's timestamp, can be used in a JOIN to get more information
        -- for that point in time
        cashflow_timestamp TIMESTAMPTZ NOT NULL,

        CONSTRAINT unique_user_product_timeline{{ g.suffix }} UNIQUE (
            user_id, product_id, "timestamp"
        )
    );

    CREATE INDEX idx_user_product_timeline_cache_{{ g.suffix }}_user_product
        ON user_product_timeline_cache_{{ g.suffix }}(user_id, product_id, "timestamp" DESC);
    CREATE INDEX idx_product_timeline_cache_{{ g.suffix }}_user_product
        ON user_product_timeline_cache_{{ g.suffix }}(product_id, "timestamp" DESC);
    CREATE INDEX idx_user_product_timeline_cache_{{ g.suffix }}_timestamp
        ON user_product_timeline_cache_{{ g.suffix }}("timestamp" DESC);

    COMMENT ON TABLE user_product_timeline_cache_{{ g.suffix }} IS
        'Cached timeline combining price updates with cashflow timestamps at {{ g.suffix }} granularity. Cache retention: {{ g.cache_retention if g.cache_retention else "unlimited" }}.';

    -- seed_pt_{{ g.suffix }}: Returns the most recent cached timeline timestamp for each product
    --
    -- Purpose: Serves as a watermark to avoid recalculating timelines from the beginning
    -- Returns: Latest timestamp from user_product_timeline_cache_{{ g.suffix }} for each product
    -- Performance: O(1) per product due to DISTINCT ON with DESC index
    -- Parameters:
    --   - p_product_id: Filter by product (NULL = all products)
    CREATE FUNCTION seed_pt_{{ g.suffix }}(p_product_id UUID)
        RETURNS TABLE(product_id UUID, "timestamp" TIMESTAMPTZ)
        LANGUAGE plpgsql STABLE AS $$
        BEGIN
            {% macro query(w='') %}
                RETURN QUERY
                SELECT DISTINCT ON (uptc.product_id) uptc.product_id, uptc."timestamp"
                FROM user_product_timeline_cache_{{ g.suffix }} uptc
                {{ w }}
                ORDER BY uptc.product_id, uptc."timestamp" DESC
            {% endmacro %}
            IF p_product_id IS NULL THEN
                {{ query() }};
            ELSE
                {{ query('WHERE uptc.product_id = p_product_id') }};
            END IF;
        END;
        $$;

    -- fresh_pu_{{ g.suffix }}: Returns new price update timestamps that haven't been cached yet
    --
    -- Purpose: Gets price updates newer than the latest cached entry (seed)
    -- Returns: Timestamps from price_update_{{ g.suffix }} that need to be added to timeline
    -- Performance: Index scan from seed timestamp onward
    -- Parameters:
    --   - p_product_id: Filter by product (NULL = all products)
    --   - p_after: Only return timestamps after this point (NULL = use seed)
    CREATE FUNCTION fresh_pu_{{ g.suffix }}(p_product_id UUID, p_after TIMESTAMPTZ)
        RETURNS TABLE(product_id UUID, "timestamp" TIMESTAMPTZ)
        LANGUAGE plpgsql STABLE AS $$
        BEGIN
            {% macro query(w='') %}
                RETURN QUERY
                SELECT pu.product_id, pu."timestamp"
                FROM price_update_{{ g.suffix }} pu
                    LEFT OUTER JOIN seed_pt_{{ g.suffix }}(p_product_id) seed_pt
                        ON pu.product_id = seed_pt.product_id
                WHERE (seed_pt."timestamp" IS NULL OR pu."timestamp" > seed_pt."timestamp") {{ w }}
            {% endmacro %}
            IF p_product_id IS NULL AND p_after IS NULL THEN
                {{ query() }};
            ELSIF p_product_id IS NOT NULL AND p_after IS NULL THEN
                {{ query('AND pu.product_id = p_product_id') }};
            ELSIF p_product_id IS NULL AND p_after IS NOT NULL THEN
                {{ query('AND pu."timestamp" > p_after') }};
            ELSIF p_product_id IS NOT NULL AND p_after IS NOT NULL THEN
                {{ query('AND pu.product_id = p_product_id AND pu."timestamp" > p_after') }};
            END IF;
        END;
        $$;

    -- user_product_timeline_{{ g.suffix }}: Returns timeline of (user, product, price_time, cashflow_time)
    --
    -- Purpose: Main query interface for user-product timeline at {{ g.suffix }} granularity
    -- Returns: Union of cached data + fresh price updates with their associated cashflow timestamps
    -- Performance: Cached portion is fast; fresh portion uses LATERAL join to find latest cashflow
    -- Note: Respects cache_retention period ({{ g.cache_retention if g.cache_retention else "unlimited" }})
    -- Parameters:
    --   - p_user_id: Filter by user (NULL = all users)
    --   - p_product_id: Filter by product (NULL = all products)
    --   - p_now: Current time for retention calculation (default: NOW())
    CREATE FUNCTION user_product_timeline_{{ g.suffix }}(
        p_user_id UUID, p_product_id UUID, p_now TIMESTAMPTZ DEFAULT NOW()
    )
        RETURNS TABLE(
            user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ, cashflow_timestamp TIMESTAMPTZ
        )
        LANGUAGE plpgsql STABLE AS $$
        DECLARE
            v_retention_period_start TIMESTAMPTZ;
        BEGIN
            {% if g.cache_retention %}
                v_retention_period_start := p_now - '{{ g.cache_retention }}'::interval;
            {% endif %}
            {% macro query(w1='', w2='') %}
                RETURN QUERY
                SELECT uptc.user_id, uptc.product_id, uptc."timestamp", uptc.cashflow_timestamp
                FROM user_product_timeline_cache_{{ g.suffix }} uptc
                WHERE
                    true  -- Doing this so that the conditional filters can start with AND
                    {{ w1 }}
                    {% if g.cache_retention %}
                        AND uptc."timestamp" >= v_retention_period_start
                    {% endif %}

                UNION ALL

                SELECT
                    latest_ccf.user_id, fresh_pu.product_id, fresh_pu."timestamp",
                    latest_ccf."timestamp" AS cashflow_timestamp
                FROM fresh_pu_{{ g.suffix }}(
                    p_product_id,
                    {% if g.cache_retention %}v_retention_period_start{% else %}NULL{% endif %}
                ) fresh_pu
                    INNER JOIN LATERAL (
                        SELECT DISTINCT ON (ccf.user_id) ccf.user_id, ccf."timestamp"
                        {% if g.cache_retention %}
                            FROM cumulative_cashflow(
                                p_user_id, p_product_id, FALSE, v_retention_period_start
                            ) ccf
                        {% else %}
                            FROM cumulative_cashflow(p_user_id, p_product_id) ccf
                        {% endif %}
                        WHERE
                            ccf.product_id = fresh_pu.product_id AND
                            ccf."timestamp" <= fresh_pu."timestamp"
                        ORDER BY ccf.user_id, ccf."timestamp" DESC
                    ) latest_ccf ON true
                {{ w2 }}
            {% endmacro %}
            IF p_user_id IS NULL AND p_product_id IS NULL THEN
                {{ query() }};
            ELSIF p_user_id IS NOT NULL AND p_product_id IS NULL THEN
                {{ query('AND uptc.user_id = p_user_id') }};
            ELSIF p_user_id IS NULL AND p_product_id IS NOT NULL THEN
                {{ query(
                    'AND uptc.product_id = p_product_id',
                    'WHERE fresh_pu.product_id = p_product_id'
                ) }};
            ELSE
                {{ query(
                    'AND uptc.user_id = p_user_id AND uptc.product_id = p_product_id',
                    'WHERE fresh_pu.product_id = p_product_id'
                ) }};
            END IF;
        END;
        $$;

    -- latest_up_{{ g.suffix }}: Returns the most recent timeline entry for each (user, product) pair
    --
    -- Purpose: Helper function for retention policy - keeps at least one row per user-product
    -- Returns: Latest timestamp for each (user, product) from the cache
    -- Performance: DISTINCT ON with DESC index
    -- Parameters:
    --   - p_user_id: Filter by user (NULL = all users)
    --   - p_product_id: Filter by product (NULL = all products)
    CREATE FUNCTION latest_up_{{ g.suffix }}(p_user_id UUID, p_product_id UUID)
        RETURNS TABLE(user_id UUID, product_id UUID, "timestamp" TIMESTAMPTZ)
        LANGUAGE plpgsql STABLE AS $$
        BEGIN
            {% macro query(w='') %}
                RETURN QUERY
                SELECT DISTINCT ON (uptc.user_id, uptc.product_id)
                    uptc.user_id, uptc.product_id, uptc."timestamp"
                FROM user_product_timeline_cache_{{ g.suffix }} uptc
                {{ w }}
                ORDER BY uptc.user_id, uptc.product_id, uptc."timestamp" DESC
            {% endmacro %}
            IF p_user_id IS NULL AND p_product_id IS NULL THEN
                {{ query() }};
            ELSIF p_user_id IS NOT NULL AND p_product_id IS NULL THEN
                {{ query('WHERE uptc.user_id = p_user_id') }};
            ELSIF p_user_id IS NULL AND p_product_id IS NOT NULL THEN
                {{ query('WHERE uptc.product_id = p_product_id') }};
            ELSE
                {{ query('WHERE uptc.user_id = p_user_id AND uptc.product_id = p_product_id') }};
            END IF;
        END;
        $$;

    -- refresh_user_product_timeline_{{ g.suffix }}: Updates the timeline cache and enforces retention
    --
    -- Purpose: Materialization job to move computed timelines into cache
    -- Side effects: Inserts new rows and deletes old rows (if retention policy applies)
    -- Performance: Processes all uncached timeline entries
    -- Usage: Call periodically to keep cache up-to-date
    -- Parameters:
    --   - p_now: Current time for retention calculation (default: NOW())
    CREATE OR REPLACE FUNCTION refresh_user_product_timeline_{{ g.suffix }}(
        p_now TIMESTAMPTZ DEFAULT NOW()
    )
        RETURNS void
        LANGUAGE plpgsql VOLATILE AS $$
        DECLARE v_watermark TIMESTAMPTZ;
        BEGIN
            SELECT MAX("timestamp") INTO v_watermark
            FROM user_product_timeline_cache_{{ g.suffix }};

            INSERT INTO user_product_timeline_cache_{{ g.suffix }} (
                user_id, product_id, "timestamp", cashflow_timestamp
            )
            SELECT user_id, product_id, "timestamp", cashflow_timestamp
            FROM user_product_timeline_{{ g.suffix }}(NULL, NULL, p_now)
            WHERE v_watermark IS NULL OR "timestamp" > v_watermark;

            {% if g.cache_retention %}

                -- Delete old rows beyond retention period, but keep at least one row per
                -- user-product
                DELETE FROM user_product_timeline_cache_{{ g.suffix }} upt
                WHERE
                    upt."timestamp" < p_now - INTERVAL '{{ g.cache_retention }}' AND
                    NOT EXISTS (
                        SELECT 1
                        FROM latest_up_{{ g.suffix }}(NULL, NULL) latest_up
                        WHERE
                            latest_up.user_id = upt.user_id AND
                            latest_up.product_id = upt.product_id AND
                            latest_up."timestamp" = upt."timestamp"
                    );

            {% endif %}
        END;
        $$;

{% endfor %}
